// Code generated by sails-client-gen. DO NOT EDIT.
#[allow(unused_imports)]
use sails_rs::collections::BTreeMap;
#[allow(unused_imports)]
use sails_rs::{
    calls::{Activation, Call, Query, Remoting, RemotingAction},
    prelude::*,
    String,
};
pub struct AppFactory<R> {
    #[allow(dead_code)]
    remoting: R,
}
impl<R> AppFactory<R> {
    #[allow(unused)]
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::AppFactory for AppFactory<R> {
    type Args = R::Args;
    fn new(&self) -> impl Activation<Args = R::Args> {
        RemotingAction::<_, app_factory::io::New>::new(self.remoting.clone(), ())
    }
    fn new_with_vnft_contract_id(
        &self,
        vnft_contract_id: ActorId,
    ) -> impl Activation<Args = R::Args> {
        RemotingAction::<_, app_factory::io::NewWithVnftContractId>::new(
            self.remoting.clone(),
            vnft_contract_id,
        )
    }
}

pub mod app_factory {
    use super::*;
    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct New(());
        impl New {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <New as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for New {
            const ROUTE: &'static [u8] = &[12, 78, 101, 119];
            type Params = ();
            type Reply = ();
        }
        pub struct NewWithVnftContractId(());
        impl NewWithVnftContractId {
            #[allow(dead_code)]
            pub fn encode_call(vnft_contract_id: ActorId) -> Vec<u8> {
                <NewWithVnftContractId as ActionIo>::encode_call(&vnft_contract_id)
            }
        }
        impl ActionIo for NewWithVnftContractId {
            const ROUTE: &'static [u8] = &[
                84, 78, 101, 119, 87, 105, 116, 104, 86, 110, 102, 116, 67, 111, 110, 116, 114, 97,
                99, 116, 73, 100,
            ];
            type Params = ActorId;
            type Reply = ();
        }
    }
}
pub struct VnftManagerSvc<R> {
    remoting: R,
}
impl<R> VnftManagerSvc<R> {
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::VnftManagerSvc for VnftManagerSvc<R> {
    type Args = R::Args;
    fn add_admin(
        &mut self,
        new_admin_address: ActorId,
    ) -> impl Call<Output = VnftManagerEvents, Args = R::Args> {
        RemotingAction::<_, vnft_manager_svc::io::AddAdmin>::new(
            self.remoting.clone(),
            new_admin_address,
        )
    }
    fn burn_nft(
        &mut self,
        from: ActorId,
        token_id: U256,
    ) -> impl Call<Output = VnftManagerEvents, Args = R::Args> {
        RemotingAction::<_, vnft_manager_svc::io::BurnNft>::new(
            self.remoting.clone(),
            (from, token_id),
        )
    }
    fn mint_nft(
        &mut self,
        to: ActorId,
        token_metadata: TokenMetadata,
    ) -> impl Call<Output = VnftManagerEvents, Args = R::Args> {
        RemotingAction::<_, vnft_manager_svc::io::MintNft>::new(
            self.remoting.clone(),
            (to, token_metadata),
        )
    }
    fn set_vft_contract_id(
        &mut self,
        vft_contract_id: ActorId,
    ) -> impl Call<Output = VnftManagerEvents, Args = R::Args> {
        RemotingAction::<_, vnft_manager_svc::io::SetVftContractId>::new(
            self.remoting.clone(),
            vft_contract_id,
        )
    }
    fn transfer_from(
        &mut self,
        from: ActorId,
        to: ActorId,
        token_id: U256,
    ) -> impl Call<Output = VnftManagerEvents, Args = R::Args> {
        RemotingAction::<_, vnft_manager_svc::io::TransferFrom>::new(
            self.remoting.clone(),
            (from, to, token_id),
        )
    }
    fn nft_address_approved(
        &self,
        token_id: U256,
    ) -> impl Query<Output = VnftManagerQueryEvents, Args = R::Args> {
        RemotingAction::<_, vnft_manager_svc::io::NftAddressApproved>::new(
            self.remoting.clone(),
            token_id,
        )
    }
    fn nft_owner_by_token_id(
        &self,
        token_id: U256,
    ) -> impl Query<Output = VnftManagerQueryEvents, Args = R::Args> {
        RemotingAction::<_, vnft_manager_svc::io::NftOwnerByTokenId>::new(
            self.remoting.clone(),
            token_id,
        )
    }
    fn num_of_nfts_from_user(
        &self,
        user_address: ActorId,
    ) -> impl Query<Output = VnftManagerQueryEvents, Args = R::Args> {
        RemotingAction::<_, vnft_manager_svc::io::NumOfNftsFromUser>::new(
            self.remoting.clone(),
            user_address,
        )
    }
}

pub mod vnft_manager_svc {
    use super::*;

    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct AddAdmin(());
        impl AddAdmin {
            #[allow(dead_code)]
            pub fn encode_call(new_admin_address: ActorId) -> Vec<u8> {
                <AddAdmin as ActionIo>::encode_call(&new_admin_address)
            }
        }
        impl ActionIo for AddAdmin {
            const ROUTE: &'static [u8] = &[
                56, 86, 110, 102, 116, 77, 97, 110, 97, 103, 101, 114, 83, 118, 99, 32, 65, 100,
                100, 65, 100, 109, 105, 110,
            ];
            type Params = ActorId;
            type Reply = super::VnftManagerEvents;
        }
        pub struct BurnNft(());
        impl BurnNft {
            #[allow(dead_code)]
            pub fn encode_call(from: ActorId, token_id: U256) -> Vec<u8> {
                <BurnNft as ActionIo>::encode_call(&(from, token_id))
            }
        }
        impl ActionIo for BurnNft {
            const ROUTE: &'static [u8] = &[
                56, 86, 110, 102, 116, 77, 97, 110, 97, 103, 101, 114, 83, 118, 99, 28, 66, 117,
                114, 110, 78, 102, 116,
            ];
            type Params = (ActorId, U256);
            type Reply = super::VnftManagerEvents;
        }
        pub struct MintNft(());
        impl MintNft {
            #[allow(dead_code)]
            pub fn encode_call(to: ActorId, token_metadata: super::TokenMetadata) -> Vec<u8> {
                <MintNft as ActionIo>::encode_call(&(to, token_metadata))
            }
        }
        impl ActionIo for MintNft {
            const ROUTE: &'static [u8] = &[
                56, 86, 110, 102, 116, 77, 97, 110, 97, 103, 101, 114, 83, 118, 99, 28, 77, 105,
                110, 116, 78, 102, 116,
            ];
            type Params = (ActorId, super::TokenMetadata);
            type Reply = super::VnftManagerEvents;
        }
        pub struct SetVftContractId(());
        impl SetVftContractId {
            #[allow(dead_code)]
            pub fn encode_call(vft_contract_id: ActorId) -> Vec<u8> {
                <SetVftContractId as ActionIo>::encode_call(&vft_contract_id)
            }
        }
        impl ActionIo for SetVftContractId {
            const ROUTE: &'static [u8] = &[
                56, 86, 110, 102, 116, 77, 97, 110, 97, 103, 101, 114, 83, 118, 99, 64, 83, 101,
                116, 86, 102, 116, 67, 111, 110, 116, 114, 97, 99, 116, 73, 100,
            ];
            type Params = ActorId;
            type Reply = super::VnftManagerEvents;
        }
        pub struct TransferFrom(());
        impl TransferFrom {
            #[allow(dead_code)]
            pub fn encode_call(from: ActorId, to: ActorId, token_id: U256) -> Vec<u8> {
                <TransferFrom as ActionIo>::encode_call(&(from, to, token_id))
            }
        }
        impl ActionIo for TransferFrom {
            const ROUTE: &'static [u8] = &[
                56, 86, 110, 102, 116, 77, 97, 110, 97, 103, 101, 114, 83, 118, 99, 48, 84, 114,
                97, 110, 115, 102, 101, 114, 70, 114, 111, 109,
            ];
            type Params = (ActorId, ActorId, U256);
            type Reply = super::VnftManagerEvents;
        }
        pub struct NftAddressApproved(());
        impl NftAddressApproved {
            #[allow(dead_code)]
            pub fn encode_call(token_id: U256) -> Vec<u8> {
                <NftAddressApproved as ActionIo>::encode_call(&token_id)
            }
        }
        impl ActionIo for NftAddressApproved {
            const ROUTE: &'static [u8] = &[
                56, 86, 110, 102, 116, 77, 97, 110, 97, 103, 101, 114, 83, 118, 99, 72, 78, 102,
                116, 65, 100, 100, 114, 101, 115, 115, 65, 112, 112, 114, 111, 118, 101, 100,
            ];
            type Params = U256;
            type Reply = super::VnftManagerQueryEvents;
        }
        pub struct NftOwnerByTokenId(());
        impl NftOwnerByTokenId {
            #[allow(dead_code)]
            pub fn encode_call(token_id: U256) -> Vec<u8> {
                <NftOwnerByTokenId as ActionIo>::encode_call(&token_id)
            }
        }
        impl ActionIo for NftOwnerByTokenId {
            const ROUTE: &'static [u8] = &[
                56, 86, 110, 102, 116, 77, 97, 110, 97, 103, 101, 114, 83, 118, 99, 68, 78, 102,
                116, 79, 119, 110, 101, 114, 66, 121, 84, 111, 107, 101, 110, 73, 100,
            ];
            type Params = U256;
            type Reply = super::VnftManagerQueryEvents;
        }
        pub struct NumOfNftsFromUser(());
        impl NumOfNftsFromUser {
            #[allow(dead_code)]
            pub fn encode_call(user_address: ActorId) -> Vec<u8> {
                <NumOfNftsFromUser as ActionIo>::encode_call(&user_address)
            }
        }
        impl ActionIo for NumOfNftsFromUser {
            const ROUTE: &'static [u8] = &[
                56, 86, 110, 102, 116, 77, 97, 110, 97, 103, 101, 114, 83, 118, 99, 68, 78, 117,
                109, 79, 102, 78, 102, 116, 115, 70, 114, 111, 109, 85, 115, 101, 114,
            ];
            type Params = ActorId;
            type Reply = super::VnftManagerQueryEvents;
        }
    }
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub enum VnftManagerEvents {
    VFTContractIdSet,
    NewNFTMinted,
    NftBurned,
    TokenTransferred,
    NewAdminAdded(ActorId),
    Error(VnftManagerErrors),
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub enum VnftManagerErrors {
    OnlyAdminsCanDoThatAction,
    VftContractIdNotSet,
    ContractIsNotApproved,
    ErrorInVNFTContract(String),
    OperationWasNotPerformed,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct TokenMetadata {
    pub name: String,
    pub description: String,
    pub media: String,
    pub reference: String,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub enum VnftManagerQueryEvents {
    UserNumOfTokensOwned(U256),
    UserNumOfTokensOwnedAsu128(u128),
    NFTAddressApproved(Option<ActorId>),
    NFTOwner(ActorId),
    Error(VnftManagerErrors),
}

pub mod traits {
    use super::*;
    #[allow(dead_code)]
    pub trait AppFactory {
        type Args;
        #[allow(clippy::new_ret_no_self)]
        #[allow(clippy::wrong_self_convention)]
        fn new(&self) -> impl Activation<Args = Self::Args>;
        fn new_with_vnft_contract_id(
            &self,
            vnft_contract_id: ActorId,
        ) -> impl Activation<Args = Self::Args>;
    }

    #[allow(clippy::type_complexity)]
    pub trait VnftManagerSvc {
        type Args;
        fn add_admin(
            &mut self,
            new_admin_address: ActorId,
        ) -> impl Call<Output = VnftManagerEvents, Args = Self::Args>;
        fn burn_nft(
            &mut self,
            from: ActorId,
            token_id: U256,
        ) -> impl Call<Output = VnftManagerEvents, Args = Self::Args>;
        fn mint_nft(
            &mut self,
            to: ActorId,
            token_metadata: TokenMetadata,
        ) -> impl Call<Output = VnftManagerEvents, Args = Self::Args>;
        fn set_vft_contract_id(
            &mut self,
            vft_contract_id: ActorId,
        ) -> impl Call<Output = VnftManagerEvents, Args = Self::Args>;
        fn transfer_from(
            &mut self,
            from: ActorId,
            to: ActorId,
            token_id: U256,
        ) -> impl Call<Output = VnftManagerEvents, Args = Self::Args>;
        fn nft_address_approved(
            &self,
            token_id: U256,
        ) -> impl Query<Output = VnftManagerQueryEvents, Args = Self::Args>;
        fn nft_owner_by_token_id(
            &self,
            token_id: U256,
        ) -> impl Query<Output = VnftManagerQueryEvents, Args = Self::Args>;
        fn num_of_nfts_from_user(
            &self,
            user_address: ActorId,
        ) -> impl Query<Output = VnftManagerQueryEvents, Args = Self::Args>;
    }
}
